#!/usr/bin/perl

use strict;
use warnings;
use File::Copy;
use Getopt::Std;

my $VER_NUM="0.9 adapt";
my @progpath=split (/\//, $0);
my $PROGNAME=$progpath[-1];

sub print_usage()
{
  print "Usage : $PROGNAME output_directory file_1.c [file_2.c ...]\n";
  exit ();
}

my %opts = ();

getopts('Vvhi:s:',\%opts) or print_usage();

if ($opts{v})
{
  print "$PROGNAME ver. $VER_NUM\n";
  exit;
}

my $output_directory;

if ((scalar @ARGV < 2) || $opts{h})
{
  print_usage();
} else {
  $output_directory = shift @ARGV;
  if ($opts{V}) {
    print "Output directory set to : $output_directory\n";
  }
  if ($output_directory =~ /\.\//)
  {
    $output_directory = "";
  }
}

if ($opts{i} && $opts{V})
{
  print "Using $opts{i} as Header\n";
}

my $splitter = "splitter";

if ($opts{s})
{
  if ($opts{V}) {
    print "Using $opts{s} as Splitter\n";
  }
  $splitter = $opts{s}
} else {
  if ($opts{V}) {
    print "Using default splitter\n";
  }
}

##########################################################
# Perl trim function to strip whitespace from a string : #
# from http://www.somacon.com/p114.php                   #
##########################################################

# Declare the subroutines
sub trim($);
sub ltrim($);
sub rtrim($);

## Create a test string
# my $string = "  \t  Hello world!   ";
#
## Here is how to output the trimmed text "Hello world!"
# print trim($string)."\n";
# print ltrim($string)."\n";
# print rtrim($string)."\n";

# Perl trim function to remove whitespace from the start and end of the string
sub trim($)
{
  my $string = shift;
  $string =~ s/^\s+//;
  $string =~ s/\s+$//;
  return $string;
}
# Left trim function to remove leading whitespace
sub ltrim($)
{
  my $string = shift;
  $string =~ s/^\s+//;
  return $string;
}
# Right trim function to remove trailing whitespace
sub rtrim($)
{
  my $string = shift;
  $string =~ s/\s+$//;
  return $string;
}

######################################

# Copy c2x.c and c2x.h files to output_directory :
print ("Copying c2x.c file to destination directory : ".$output_directory."c2x.c\n");
copy($ENV{'HOME'}."/bin/.c2x.c", $output_directory."c2x.c") or die "Copy failed: $!";
print ("Copying c2x.h file to destination directory : ".$output_directory."c2x.h\n");
copy($ENV{'HOME'}."/bin/.c2x.h", $output_directory."c2x.h") or die "Copy failed: $!";

######################################

my $header_file = $output_directory . "main.h";

if ($opts{V}) {
  print "Generating main header : $header_file . . .";
}

open(HEADER, ">$header_file") or die $!;

print HEADER <<EOP;
/*
 * $header_file.
 *
 * Generated by $PROGNAME version $VER_NUM.
 *
 */

#include <kaapi.h>
#include <stddef.h>

/* GTG ugly stuff : */
extern uint64_t epoc;
EOP

if ($opts{i})
{
  print HEADER "#include \"$opts{i}\"\n";
}

my $input_directory = $ARGV[0];

opendir(DIR, $input_directory);
my @files = readdir(DIR);
closedir(DIR);

my @c_files = grep(/\.c$/,@files);
my @h_files = grep(/\.h$/,@files);

foreach my $file (@c_files)
{
  open(FILEHANDLER, $input_directory . "/" . $file) or die $!;
  while (my $line = <FILEHANDLER>)
  {
    if ($line =~ / METHOD\s*\(.*,\s*(.*)\)\s*\(\s*void\s*\*\s*_this\s*,*(.*)\)/)
    {
      my $function = $1;
      my @args = split (/,/, $2);

      &WriteHeader ($function, @args);
    }
  }
}

if ($opts{V}) {
  print " . . . done\n";
}

# ATM Simply copy each header file in source folder to destination folder without processing :
foreach my $file (@h_files)
{
  if ($opts{V}) {
    print ("Copying header file to destination directory : $file\n");
  }
  copy ($input_directory . "/" . $file, $output_directory . $file) or die "Copy failed: $!";
}


open(HEADER, $header_file) or die $!;

# Unique task name :
my $taskId = 1;

foreach my $file (@c_files)
{
  if ($opts{V}){
    print "Processing file $file to " . $output_directory . $file . " . . .";
  }

  my @splitted_path = split (/\//, $file);
  my $file_out = $output_directory.$splitted_path[$#splitted_path];
  open(FILEHANDLER, $input_directory . "/" . $file) or die $!;
  open(FILEOUT, ">$file_out") or die $!;

  print FILEOUT <<EOP;
/*
 * $file_out.
 *
 * Generated by $PROGNAME version $VER_NUM.
 *
 */
EOP

  while (my $line = <FILEHANDLER>)
  {
    # 1. Suppress DECLARE_DATA :
    # for perl parsing script, need to have this indentation for DECLARE_DATA :
    # DECLARE_DATA {
    #  ...
    # }
    my $nb_cb = 0;
    if($line =~ /DECLARE_DATA\s*{/)
    {
      $nb_cb++;
      while(defined($line = <FILEHANDLER>) && $nb_cb != 0)
      {
        
        if(my @arr = $line =~ /{/g)
        {
          $nb_cb += @arr;
        }

        if(my @arr = $line =~ /}/g)
        {
          $nb_cb -= @arr;
        } else {
          # use volatile qualifier only if the line isn't a comment :
          if (ltrim($line) =~ /^\/\//)
          {
            print FILEOUT ltrim($line) . "\n";
          } else {
            print FILEOUT "volatile " . ltrim($line) . "\n";
          }
        }
      }
    }

    # 2. Change included header :
    elsif($line =~ /#include .cecilia\.h./)
    {
      print FILEOUT "\#include \"$header_file\"\n";
      print FILEOUT "\#include \"c2x.h\"\n";
      # TODO : add splitter_header file in option if user want generic splitter
      # or his own splitter.
      #print FILEOUT "\#include \"$splitter_header\"";
    }

    # 3. Method re-definition and header update :
    elsif ($line =~ / METHOD\s*\(.*,\s*(.*)\)\s*\(\s*void\s*\*\s*_this\s*,*(.*)\)/)
    {
      my $function = $1;
      my @args = split (/,/, $2);


      $line = <FILEHANDLER>;
      if ($line !~ /{/)
      {
        print FILEOUT $line;
      }

      print FILEOUT "void ".$function."_body (void* taskarg)\n"; 
      print FILEOUT "{\n";

      # Function declaration and argument decapsulation :
      if ($#args != -1)
      {
        print FILEOUT "  ".$function."_arg_t* arg0 = (".$function."_arg_t*) taskarg;\n\n";

        foreach my $arg (@args)
        {
          $arg =~ /.*\s\**([A-Za-z_][A-Za-z0-9_]*)/ or die "No match found";
          print FILEOUT " $arg = arg0->$1;\n";
        }
        print FILEOUT "\n";
      } else {
        # No arguments :
      }
    }

    # 4. CALL becomes task :
    # elsif ($line =~ /^\s*CALL\s*\([^,]*,\s*([^,]*),(.*)\)\s*;/)
    elsif ($line =~ /^\s*CALL\s*\([^,]*,\s*(.*)\)\s*;/)
    {
      my @args = split (/,/, $1);
      my $function = $args[0];

      print FILEOUT "  component_call_t* data_$taskId = (component_call_t*) malloc (sizeof (component_call_t));\n";
      print FILEOUT "  ".$function."_arg_t* ".$function."_args = (".$function."_arg_t*) malloc (sizeof (".$function."_arg_t));\n";

      for (my $i = 1; $i <= $#args; $i++)
      {
        #$args[$i] =~ /.*\s\**([A-Za-z_][A-Za-z0-9_]*)/ or die "No match found";
        my $var_name = &Var_Name_Func ($function, $i);
        print FILEOUT "  ".$function."_args->".$var_name." = $args[$i];\n";
      }

      print FILEOUT "  data_".$taskId."->meth = (methode_t) ".$function."_body;\n";
      print FILEOUT "  data_".$taskId."->args = ".$function."_args;\n";
      print FILEOUT "  c2x_push (&work, data_$taskId);\n";
      
      # Increment taskId to guarantee unique task name :
      $taskId++;
    }

    # 5. CALLMINE becomes task :
    elsif ($line =~ /^\s*CALLMINE\s*\([^,]*,\s*(.*)\)\s*;/)
    {
      my @args = split (/,/, $1);
      my $function = $args[0];

      # TODO : when will this be freed? at the end of the task in the thief
      # entrypoint!
      print FILEOUT "  ".$function."_arg_t* ".$function."_args = (".$function."_arg_t*) malloc (sizeof (".$function."_arg_t));\n";
      #print FILEOUT "  task_$taskId = kaapi_thread_toptask(thread);\n";
      #print FILEOUT "  kaapi_task_initdfg( task_$taskId, ".$function."_body, kaapi_thread_pushdata(thread, sizeof(".$function."_arg_t)) );\n";
      #print FILEOUT "  ".$function."_args = kaapi_task_getargst( task_$taskId, ".$function."_arg_t );\n";

      for (my $i = 1; $i <= $#args; $i++)
      {
        #$args[$i] =~ /.*\s\**([A-Za-z_][A-Za-z0-9_]*)/ or die "No match found";
        my $var_name = &Var_Name_Func ($function, $i);
        print FILEOUT "  ".$function."_args->".$var_name." = $args[$i];\n";
      }

      print FILEOUT "  kaapi_workqueue_push_one (work, ".$function."_args);\n";
    
      # Increment taskId to guarantee unique task name :
      $taskId++;
    }

    # 6. Normal C line :
    else
    {
      $line =~ s/DATA\.//g;
      print FILEOUT $line;
    }
  }
  print FILEOUT "\n";
  if ($opts{V}){
    print " . . . done\n";
  }
}

sub Var_Name_Func {
  (my $function, my $index) = @_;
  open (HEADER, $header_file);

  while (my $line = <HEADER>)
  {
    if ($line =~ /typedef struct ($function)_arg_t/)
    {
      for (my $j = 0; $j < $index; $j++)
      {
        $line = <HEADER>;
      }
      $line =~ /.*\s\**([A-Za-z_][A-Za-z0-9_]*)/;
      return $1;
    }
  }
}

sub WriteHeader {
  (my $function, my @args) = @_;
  #@args = split (/,/, $arguments);

  print HEADER "\n/**********************************************************************/\n\n";
  print HEADER "/* $function function prototype : */\n\n";

  #if ($#args == -1) {
  #  print HEADER "void ".$function."_body (kaapi_thread_t* thread);\n\n";  
  #} else {
    print HEADER "void ".$function."_body (void* taskarg);\n\n";  
    #}

  if ($#args != -1) {
    print HEADER "/* $function argument structure : */\n\n";
    print HEADER "typedef struct ".$function."_arg_t {\n";

    foreach my $my_arg (@args)
    {
      print HEADER "\t$my_arg;\n";
    }
    print HEADER "} ".$function."_arg_t;\n\n";
  }

}

###################
# Creating main.c #
###################

my $main_file = $output_directory . "main.c";

open(MAINFILE, ">$main_file") or die $!;

if ($opts{V}){
  print "Generating XKaapi entrypoing file : $main_file . . .";
}

print MAINFILE <<EOP;
/*
 * main.c
 *
 * Generated by c2x version 0.9 adapt.
 *
 * Created by Christophe Laferriere on 22/11/10.
 * Copyright 2010 INRIA. All rights reserved.
 *
 */
#include <kaapi.h>
#include <sys/time.h>
#include "main.h"
#include "c2x.h"

#ifdef C2X_USES_GTG
# include "timing.h"
#endif //C2X_USES_GTG

#define MAX_COMP_CALL 20000

work_t work;
uint64_t epoc = 0;

int main (int argc, char** argv)
{
  main_arg_t* args;
  kaapi_thread_t* thread;
  kaapi_stealcontext_t* sc;

  /* WorkQueue initialization : */
  work.array = (component_call_t **) malloc (sizeof (component_call_t*) * MAX_COMP_CALL * 2);
  c2x_workqueue_init (&work.wq, MAX_COMP_CALL * 2);

#ifdef C2X_USES_TIMING
  /* Timing lib. initialisation : */
  timing_init();
#endif //C2X_USES_TIMING

  /* Library initialization : */
  kaapi_init (&argc, &argv);
  thread = kaapi_self_thread ();
  
#ifdef C2X_USES_GTG
  /* GTG init for PAJE traces : */
  setTraceType (PAJE);
  initTrace ("trace", 0, GTG_FLAG_NONE);

  addContType ("T", "0", "Thread");
  addStateType ("S", "T", "State");
  
  addEntityValue ("Te", "S", "Thief_Entrypoint", GTG_DARKGREY);
  addEntityValue ("St", "S", "Steal", GTG_LIGHTGREY);
  addEntityValue ("Xk", "S", "XKaapi", GTG_WHITE);
  addEntityValue ("Sp", "S", "Splitter", GTG_DARKBLUE);
  addContainer (0, "P", "T", "0", "machine", "0");
  addVarType ("W", "WorkQueue Size", "T");

  /* Add a container for every kaapi_threads : */
  for (int i = 1; i <= kaapi_getconcurrency(); i++)
  {
    char buf[3];
    sprintf(buf, "%d", i); 
    addContainer (0, buf, "T", "P", buf, "0");
  }
#endif //C2X_USES_GTG

  struct timeval start;
  gettimeofday (&start, NULL);
  epoc = start.tv_sec * 1000000 + start.tv_usec;

  /* Push an adaptive task : */
  sc = kaapi_task_begin_adaptive (thread, KAAPI_SC_CONCURRENT, $splitter, &work);

  /* Now let's do the work! */
  args = (main_arg_t*) malloc (sizeof (main_arg_t));
  args->argc = argc;
  args->argv = argv;
  main_body (args);

  /* Wait for thieves : */
  kaapi_task_end_adaptive (sc);

  /* Library termination : */
  kaapi_finalize();

#ifdef C2X_USES_GTG
  /* Trace writing */
  endTrace();
#endif //C2X_USES_GTG

  /* Free some stuff : */
  // TODO : destroy or not?
  //c2x_workqueue_destroy (&work.wq);
  free (work.array);
  free (args);

  return 0;
}
EOP

close (MAINFILE);
if ($opts{V}){
  print " . . . done\n";
}
